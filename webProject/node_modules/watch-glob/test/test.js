(function() {
  var expect, fs, path, rimraf, sinon, watchGlob;

  expect = require('chai').expect;

  sinon = require('sinon');

  fs = require('fs');

  path = require('path');

  rimraf = require('rimraf');

  watchGlob = require('../src/index.coffee');

  describe('watch-glob', function() {
    var delay, delayForWatch, spyAdded, spyRemoved, testFilePath;
    delay = function(t, f) {
      return setTimeout(f, t);
    };
    delayForWatch = function(f) {
      return delay(500, f);
    };
    testFilePath = function(f) {
      if (f == null) {
        f = '';
      }
      return path.normalize(path.join(__dirname, 'tmp', f));
    };
    spyAdded = null;
    spyRemoved = null;
    before(function() {
      rimraf.sync(testFilePath());
      try {
        return fs.mkdirSync(testFilePath());
      } catch (error) {}
    });
    beforeEach(function(done) {
      fs.writeFileSync(testFilePath('f1.txt'), '');
      spyAdded = sinon.spy();
      spyRemoved = sinon.spy();
      return delayForWatch(done);
    });
    it('should call `addedCallback` when file changes', function(done) {
      var w;
      w = watchGlob('test/tmp/f1.txt', {
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.writeFileSync(testFilePath('f1.txt'), 'test');
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(1);
          expect(spyAdded.firstCall.args[0]).to.have.property('relative').that.equals(path.normalize('test/tmp/f1.txt'));
          expect(spyAdded.firstCall.args[0]).to.have.property('base').that.equals(path.normalize(process.cwd()));
          expect(spyAdded.firstCall.args[0]).to.have.property('path').that.equals(testFilePath('f1.txt'));
          expect(spyRemoved.callCount).to.equal(0);
          w.destroy();
          return done();
        });
      });
    });
    it('should not call after destroy', function(done) {
      var w;
      w = watchGlob('test/tmp/f1.txt', {
        delay: 0
      }, spyAdded, spyRemoved);
      w.destroy();
      return delay(10, function() {
        fs.writeFileSync(testFilePath('f1.txt'), 'test');
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(0);
          expect(spyRemoved.callCount).to.equal(0);
          return done();
        });
      });
    });
    it('should call `addedCallback` when file is added', function(done) {
      var w;
      w = watchGlob('test/tmp/*', {
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.writeFileSync(testFilePath('added1.txt'), 'test');
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(1);
          expect(spyAdded.firstCall.args[0].relative).to.equal(path.normalize('test/tmp/added1.txt'));
          expect(spyRemoved.callCount).to.equal(0);
          w.destroy();
          return done();
        });
      });
    });
    it('should call `addedCallback` when file is "created" through rename', function(done) {
      var w;
      fs.writeFileSync(testFilePath('torename1.txt'), 'test');
      w = watchGlob('test/tmp/*', {
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.renameSync(testFilePath('torename1.txt'), testFilePath('renamed1.txt'));
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(1);
          expect(spyAdded.firstCall.args[0].relative).to.equal(path.normalize('test/tmp/renamed1.txt'));
          w.destroy();
          return done();
        });
      });
    });
    it('should call `removedCallback` when file is "deleted" through rename', function(done) {
      var w;
      fs.writeFileSync(testFilePath('torename1.txt'), 'test');
      w = watchGlob('test/tmp/torename*', {
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.renameSync(testFilePath('torename1.txt'), testFilePath('renamed1.txt'));
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(0);
          expect(spyRemoved.callCount).to.equal(1);
          expect(spyRemoved.firstCall.args[0].relative).to.equal(path.normalize('test/tmp/torename1.txt'));
          w.destroy();
          return done();
        });
      });
    });
    it('should call `removedCallback` when file is deleted', function(done) {
      var w;
      fs.writeFileSync(testFilePath('todelete1.txt'), 'test');
      w = watchGlob('test/tmp/todelete*', {
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.unlinkSync(testFilePath('todelete1.txt'));
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(0);
          expect(spyRemoved.callCount).to.equal(1);
          expect(spyRemoved.firstCall.args[0].relative).to.equal(path.normalize('test/tmp/todelete1.txt'));
          w.destroy();
          return done();
        });
      });
    });
    it('should work when `options` is not specified', function(done) {
      var w;
      this.timeout(5000);
      w = watchGlob('test/tmp/f1.txt', spyAdded, spyRemoved);
      return delay(3000, function() {
        fs.writeFileSync(testFilePath('f1.txt'), 'test');
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(1);
          expect(spyRemoved.callCount).to.equal(0);
          w.destroy();
          return done();
        });
      });
    });
    it('should receive `cwd` option', function(done) {
      var w;
      w = watchGlob('f1.txt', {
        cwd: testFilePath(),
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.writeFileSync(testFilePath('f1.txt'), 'test');
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(1);
          expect(spyAdded.firstCall.args[0]).to.have.property('relative').that.equals('f1.txt');
          expect(spyAdded.firstCall.args[0]).to.have.property('base').that.equals(testFilePath());
          expect(spyAdded.firstCall.args[0]).to.have.property('path').that.equals(testFilePath('f1.txt'));
          expect(spyRemoved.callCount).to.equal(0);
          w.destroy();
          return done();
        });
      });
    });
    it('should not trigger on subdirectory create which does not match pattern', function(done) {
      var w;
      w = watchGlob('test/tmp/**/*.txt', {
        delay: 0
      }, spyAdded, spyRemoved);
      return delay(10, function() {
        fs.mkdirSync(testFilePath('subdir'));
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(0);
          expect(spyRemoved.callCount).to.equal(0);
          w.destroy();
          return done();
        });
      });
    });
    it('should use base path when string is given instead of options', function(done) {
      var w;
      this.timeout(5000);
      w = watchGlob('f1.txt', testFilePath(), spyAdded, spyRemoved);
      return delay(3000, function() {
        fs.writeFileSync(testFilePath('f1.txt'), 'test');
        return delayForWatch(function() {
          expect(spyAdded.callCount).to.equal(1);
          expect(spyAdded.firstCall.args[0]).to.have.property('relative').that.equals('f1.txt');
          expect(spyAdded.firstCall.args[0]).to.have.property('base').that.equals(testFilePath());
          expect(spyAdded.firstCall.args[0]).to.have.property('path').that.equals(testFilePath('f1.txt'));
          expect(spyRemoved.callCount).to.equal(0);
          w.destroy();
          return done();
        });
      });
    });
    return describe('callbackArg', function() {
      it('should support `relative`', function(done) {
        var w;
        w = watchGlob('test/tmp/f1.txt', {
          callbackArg: 'relative',
          delay: 0
        }, spyAdded, spyRemoved);
        return delay(10, function() {
          fs.writeFileSync(testFilePath('f1.txt'), 'test');
          return delayForWatch(function() {
            expect(spyAdded.callCount).to.equal(1);
            expect(spyAdded.firstCall.args[0]).to.equal(path.normalize('test/tmp/f1.txt'));
            w.destroy();
            return done();
          });
        });
      });
      it('should support `absolute`', function(done) {
        var w;
        w = watchGlob('test/tmp/f1.txt', {
          callbackArg: 'absolute',
          delay: 0
        }, spyAdded, spyRemoved);
        return delay(10, function() {
          fs.writeFileSync(testFilePath('f1.txt'), 'test');
          return delayForWatch(function() {
            expect(spyAdded.callCount).to.equal(1);
            expect(spyAdded.firstCall.args[0]).to.equal(testFilePath('f1.txt'));
            w.destroy();
            return done();
          });
        });
      });
      return it('should support `vinyl`', function(done) {
        var w;
        w = watchGlob('test/tmp/f1.txt', {
          callbackArg: 'vinyl',
          delay: 0
        }, spyAdded, spyRemoved);
        return delay(10, function() {
          fs.writeFileSync(testFilePath('f1.txt'), 'test');
          return delayForWatch(function() {
            expect(spyAdded.callCount).to.equal(1);
            expect(spyAdded.firstCall.args[0]).to.have.property('relative').that.equals(path.normalize('test/tmp/f1.txt'));
            expect(spyAdded.firstCall.args[0]).to.have.property('base').that.equals(path.normalize(process.cwd()));
            expect(spyAdded.firstCall.args[0]).to.have.property('path').that.equals(testFilePath('f1.txt'));
            return done();
          });
        });
      });
    });
  });

}).call(this);
